/* Example client application that uses the PreSeQL database
 * PreSeQL is an embedded database - this means that it needs a client application to make sense
 * */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "preseql.h"

#define INPUT_BUFFER_SIZE 1024

PSqlStatus psql_prepare(char *preseql_input, PSqlStatement *statement) {

    Token **token_stream = NULL;
    size_t token_count = 0;

    if (tokenize(preseql_input, &token_stream, &token_count)) {
        return PSQL_ERROR;
    }

    for (size_t i = 0; i < token_count; i++) {
        printf("Token { type: %d, lexeme: '%s', line: %d }\n",
            token_stream[i]->type,
            token_stream[i]->lexeme,
            token_stream[i]->line_number);
    }

    int stmt_type;
    void *stmt = parse_tokens_with_type(token_stream, token_count, &stmt_type);

    if (stmt)
    {
        printf("Statement parsed successfully\n");

        // Generate code
        CompiledProgram *program = generate_code(stmt, stmt_type);

        if (program)
        {
            // Print the generated program
            printf("\n--- GENERATED BYTECODE ---\n");
            print_program(program);
            printf("------------------------\n\n");

            // TODO: Execute the program with a virtual machine
            // vm_execute(program);

            // Free program resources
            free_program(program);
        }
        else
        {
            printf("Code generation failed\n");
        }

        // Free the statement based on its type
        switch (stmt_type)
        {
        case STMT_SELECT:
            free_select_statement((SelectStatement *)stmt);
            break;
        case STMT_BEGIN:
        case STMT_COMMIT:
        case STMT_ROLLBACK:
            free(stmt);
            break;
        }
    }
    else
    {
        printf("Parsing failed\n");
    }

    // TODO: Fill up the PSqlStatement Struct
    statement->pc = 0;

    free_tokens(token_stream, token_count);
    return PSQL_OK;
    
}

int main() {

    char preseql_input[INPUT_BUFFER_SIZE];
    char *statement_buffer = NULL;
    PSqlStatement statement;
    size_t statement_len = 0;

    // PSql db = {
    //     .filename = "test.pseql",
    //     .flags = 0,       // optional: define read-only, etc.
    //     .pager = NULL,
    //     .error_msg = NULL
    // };

    // if (psql_open(&db) != PSQL_OK) {
    //     fprintf(stderr, "Error: failed to open database.\n");
    //     return 1;
    // }

    printf("Welcome to PreSeQL\n");
    printf("Type Statments or 'exit' to quit\n");

    while (1) {
        
        // Running Client
        printf(statement_len == 0 ? "preseql> " : "   --> ");
        if (!fgets(preseql_input, INPUT_BUFFER_SIZE, stdin)) {
            printf("\nExiting.\n");
            break;
        }

        // Remove all trailing \n and replace with null terminator
        size_t len = strlen(preseql_input);
        if (preseql_input[len - 1] == '\n') preseql_input[len - 1] = '\0';

        // Exit the Program
        if (statement_len == 0 && (strcmp(preseql_input, "exit") == 0 || strcmp(preseql_input, ".quit") == 0) ){
            printf("Goodbye. \n");
            break;
        }

        // Clear screen
        if (statement_len == 0 && strcmp(preseql_input, "clear") == 0) {
            printf("\033[2J\033[H");  
            fflush(stdout);
            continue;
        }

        // Append input line to full statement buffer
        size_t line_len = strlen(preseql_input);
        char *new_statement = realloc(statement_buffer, statement_len + line_len + 1);
        if (!new_statement) {
            fprintf(stderr, "Memory allocation failed.\n");
            free(statement_buffer);
            break;
        }

        statement_buffer = new_statement;
        memcpy(statement_buffer + statement_len, preseql_input, line_len);
        statement_len += line_len;
        statement_buffer[statement_len] = '\0';

        if (strchr(preseql_input, ';')) {

            if (psql_prepare(statement_buffer, &statement) != PSQL_OK) {
                statement_buffer = NULL;
                statement_len = 0;
                continue;
            }

            statement_buffer = NULL;
            statement_len = 0;
        }
    }

    // psql_close(&db);
    free(statement_buffer);
    
    return EXIT_SUCCESS;
}